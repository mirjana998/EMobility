package com.example.epj2.controller;

import com.example.epj2.MainWindow;
import com.example.epj2.model.Configuration;
import com.example.epj2.model.electricvehicle.*;
import com.example.epj2.model.map.Field;
import com.example.epj2.model.rent.*;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

import java.io.*;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

/**
 * Controller class for mainWindow.fxml file.
 */
public class MainWindowController implements Initializable {
    /**
     *  A map that groups rents by their date and time.
     *  The key is a LocalDateTime representing the date and time of the rent,
     *  * and the value is a list of Rent objects associated with that date and time.
     */
    public static Map<LocalDateTime, List<Rent>> rentsGroupedByDateTime = new HashMap<>();

    /**
     * A map that groups invoices by their date.
     * The key is a LocalDate representing the date of the invoice,
     * and the value is a list of Invoice objects associated with that date.
     */
    public static Map<LocalDate, List<Invoice>> invoicesGroupedByDate = new HashMap<>();
    /**
     *  A map that associates electric vehicles with their total income.
     *  The key is an ElectricVehicle object representing the vehicle,
     *  and the value is a Double representing the total income generated by that vehicle.
     */
    public static Map<ElectricVehicle,Double> vehiclesIncomeMap = new HashMap<>();

    /**
     * A list of all electric vehicles.
     */
    public static List<ElectricVehicle> vehicleList = new ArrayList<>();

    /**
     * A list of all electric vehicle rents.
     */
    public static List<Rent> rentList = new ArrayList<>();
    /**
     * A list of all electric vehicle users.
     */
    public static List<User> userList = new ArrayList<>();

    /**
     * A list of all date and times a rent was made.
     */
    public static List<LocalDateTime> dateTimeList = new ArrayList<>();
    /**
     * A list of vehicles rented at same time.
     */
    public static List<ElectricVehicle> currentVehicles = new ArrayList<>();
    /**
     * A list of rents made at same time.
     */
    public static List<Rent> currentRents = new ArrayList<>();
    /**
     * A list of all invoices for one electric vehicle rent company.
     */
    public static List<Invoice> invoiceList = new ArrayList<>();
    /**
     * A list of all malfunctions that occurred on vehicles of one electric vehicle rental company.
     */
    public static List<Malfunction> malfunctionList = new ArrayList<>();
    /**
     * A list of daily reports of one electric vehicle rental company.
     */
    public static List<Report> reportList = new ArrayList<>();
    /**
     * A map of the city where the rents being made.
     */
    public static Field[][] cityMap = new Field[20][20];
    /**
     * A 2D array of Pane objects representing the static layout of the city map.
     */
    public static Pane[][] staticPanes = new Pane[20][20];
    private FileWatcher fileWatcher = new FileWatcher();

    private static MainWindowController instance;

    /**
     * Constructs a new MainWindowController object;
     */
    public MainWindowController() {
        instance = this;
    }

    /**
     * Gets the instance of an MainWindowController
     * @return the instance of an MainWindowController
     */
    public static MainWindowController getInstance() {
        return instance;
    }

    @FXML
    private GridPane mapGrdPane;

    @FXML
    private Button exitBtn;

    @FXML
    private Button startBtn;

    @FXML
    private Button serializeBtn;

    @FXML
    private Button malfunctionsBtn;

    @FXML
    private Button vehiclesBtn;

    @FXML
    private Button minimizeBtn;

    @FXML
    private Button reportsBtn;

    @FXML
    void exitBtnClicked(ActionEvent event) {
        Stage stage = (Stage) exitBtn.getScene().getWindow();
        stage.close();
    }

    @FXML
    void minimizeBtnClicked(ActionEvent event) {
        Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
        stage.setIconified(true);
    }

    @FXML
    void serializeBtnClicked(ActionEvent event) {
        try {
            Car carMaxIncome = deserializeCar(Configuration.getCarSerializeFile());
            Bicycle bicycleMaxIncome  =  deserializeBicycle(Configuration.getBicycleSerializeFile());
            Scooter scooterMaxIncome = deserializeScooter(Configuration.getScooterSerializeFile());
            Double carIncome = deserializeVehicleIncome(Configuration.getCarIncomeSerializeFile());
            Double bicycleIncome = deserializeVehicleIncome(Configuration.getBicycleIncomeSerializeFile());
            Double scooterIncome = deserializeVehicleIncome(Configuration.getScooterIncomeSerializeFile());

            FXMLLoader loader = new FXMLLoader(MainWindow.class.getResource("deserializeWindow.fxml"));
            loader.setControllerFactory(c -> new DeserializeWindowController(carMaxIncome,bicycleMaxIncome,scooterMaxIncome, carIncome, bicycleIncome,scooterIncome));
            Parent root = loader.load();
            Stage stage = new Stage();
            stage.initStyle(StageStyle.UNDECORATED);
            stage.setScene(new Scene(root,1180,420));
            stage.show();
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }

    @FXML
    void malfunctionsBtnClicked(ActionEvent event) {
        try {
            FXMLLoader loader = new FXMLLoader(MainWindow.class.getResource("malfunctionsWindow.fxml"));
            loader.setControllerFactory(c -> new MalfunctionsWindowController(malfunctionList));
            Parent root = loader.load();
            Stage stage = new Stage();
            stage.initStyle(StageStyle.UNDECORATED);
            stage.setScene(new Scene(root,700,300));
            stage.show();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @FXML
    void reportsBtnClicked(ActionEvent event) {
        try {
            FXMLLoader loader = new FXMLLoader(MainWindow.class.getResource("reportsWindow.fxml"));
            loader.setControllerFactory(c -> new ReportsWindowController(reportList));
            Parent root = loader.load();
            Stage stage = new Stage();
            stage.initStyle(StageStyle.UNDECORATED);
            stage.setScene(new Scene(root,1000,480));
            stage.show();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @FXML
    void vehiclesBtnClicked(ActionEvent event) {
        try {
            FXMLLoader loader = new FXMLLoader(MainWindow.class.getResource("allVehiclesWindow.fxml"));
            loader.setControllerFactory(c -> new AllVehiclesWindowController(vehicleList));
            Parent root = loader.load();
            Stage stage = new Stage();
            stage.initStyle(StageStyle.UNDECORATED);
            stage.setScene(new Scene(root,780,610));
            stage.show();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void updateBtn() {
        MainWindowController controller = MainWindowController.getInstance();
        if (controller != null) {
            controller.serializeBtn.setDisable(false);
        }
    }


    /**
     * Initializes FXML objects on the window.
     * @param location the URL of the FXML document used to create this window
     * @param resources the {@link ResourceBundle} used to localize the UI elements
     */
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        for(int i=0; i<20; i++) {
            cityMap[i] = new Field[20];
            staticPanes[i] = new Pane[20];
            for(int j= 0; j<20;j++) {
                cityMap[i][j] = new Field();
                if(j>=5 && j<=14 && i>=5 && i<=14) {
                    cityMap[i][j].setOuterArea(false);
                }
                staticPanes[i][j] = new Pane();
                mapGrdPane.add(staticPanes[i][j],j,i);
            }
        }
    }

    @FXML
        void startBtnClicked(ActionEvent event) {
        try {
            BufferedReader bfRents = new BufferedReader(new FileReader(new File(Thread.currentThread().getContextClassLoader().getResource(Configuration.getRentsFile()).toURI())));
            List<String> allRents = bfRents.lines().skip(1).toList();

            BufferedReader bfVehicles = new BufferedReader(new FileReader(new File(Thread.currentThread().getContextClassLoader().getResource(Configuration.getVehiclesFile()).toURI())));
            List<String> allVehicles = bfVehicles.lines().skip(1).toList();

            allVehicles.stream().forEach(item ->parseVehicles(item)); //makes ElectricVehicle objects from allRents list
            allRents.stream().forEach(item->parseRents(item)); //makes rentList = list of Rent objects from allRents string list

            rentsGroupedByDateTime = rentList.stream() //makes a map of rent list with localDateTime key
                    .collect(Collectors.groupingBy(Rent::getDateTime));

            removeDuplicates(rentsGroupedByDateTime); //removes user and vehicle duplicates


            vehiclesBtn.setDisable(false);

            Set<LocalDateTime> dateTimeKeys = rentsGroupedByDateTime.keySet();
            dateTimeList = new ArrayList<>(dateTimeKeys); //list of all dates and times
            Collections.sort(dateTimeList); //sorts list of all dates and times


            runVehicles(0);
            Thread fileWatch = new Thread(new Runnable() { //need to do this , otherwise my threads work ,but main JAVAFX thread
                //doesn't do a thing , goes into file watcher method check() and cant get out
                @Override
                public void run() {
                    fileWatcher.check();
                }
            });
            fileWatch.start();

        }catch(Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Starts vehicles that are rented at the same time.
     * @param number the ordinal number of currentRent list
     */
    public static void runVehicles(int number){
        if(number==rentsGroupedByDateTime.size()) {
            updateVehiclesIncomeMap();
        }
        else {
            currentRents = new ArrayList<>();
            currentRents = rentsGroupedByDateTime.get(dateTimeList.get(number));
            updateUserRentCount(currentRents); //counts number of rents for each user
            updateCurrentVehicle(currentRents);
            for (ElectricVehicle currentVehicle : currentVehicles) {
                currentVehicle.start();
            }
        }
    }


    private void parseVehicles(String s) {
        try {
        String[] attributes = s.split(Configuration.getFileRegex());
            if (attributes.length != Integer.parseInt(Configuration.getVehiclesAttributesNumber())) {
                System.out.println("Not enough vehicle attributes");
            } else {
                boolean vehicleExist = vehicleList.stream().anyMatch(vehicle -> vehicle.getVehicleId().equals(attributes[0]));
                if (vehicleExist) {
                    System.out.println("VehicleID: " + attributes[0] + " already in vehicle list");
                } else {
                    if (Configuration.getCarVehicleType().equals(attributes[8])) {
                        SimpleDateFormat dateFormat = new SimpleDateFormat(Configuration.getCarDateFormat());
                        try {
                            Car car = new Car(attributes[0], Double.parseDouble(attributes[4]), attributes[1], attributes[2], 100, dateFormat.parse(attributes[3]), attributes[7]);
                            vehicleList.add(car);
                        } catch (ParseException e) {
                            e.printStackTrace();
                        }
                    } else if (Configuration.getBicycleVehicleType().equals(attributes[8])) {
                        Bicycle bicycle = new Bicycle(attributes[0], Double.parseDouble(attributes[4]), attributes[1], attributes[2], 100, Integer.parseInt(attributes[5]));
                        vehicleList.add(bicycle);
                    } else if ((Configuration.getScooterVehicleType().equals(attributes[8]))) {
                        Scooter scooter = new Scooter(attributes[0], Double.parseDouble(attributes[4]), attributes[1], attributes[2], 100, Integer.parseInt(attributes[6]));
                        vehicleList.add(scooter);
                    } else {
                        System.out.println("Type of vehicle not found.");
                    }

                }
            }
        }catch (IOException exception) {
            exception.printStackTrace();
        }
    }

    private void parseRents(String s) {
        try {
        String[] attributes = s.split(Configuration.getFileRegex());
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(Configuration.getRentDateFormat());
        boolean userExist =  userList.stream().anyMatch(user -> user.getUsername().equals(attributes[1]));
        boolean vehicleExist =  vehicleList.stream().anyMatch(vehicle -> vehicle.getVehicleId().equals(attributes[2]));
            if (attributes.length != Integer.parseInt(Configuration.getRentsAttributesNumber())) {
                System.out.println("Invalid number of rent attributes.");
            } else {
                if (vehicleExist) {
                    if (!userExist) {
                        User user = new User(attributes[1]);
                        userList.add(user);
                    }
                    LocalDateTime dateTime = LocalDateTime.parse(attributes[0], formatter);
                    if(attributes[3].contains("\"") && attributes[4].contains("\"") && attributes[5].contains("\"") && attributes[6].contains("\"")) {
                        int startX = Integer.parseInt(attributes[3].replace("\"", ""));
                        int startY = Integer.parseInt(attributes[4].replace("\"", ""));
                        int endX = Integer.parseInt(attributes[5].replace("\"", ""));
                        int endY = Integer.parseInt(attributes[6].replace("\"", ""));
                        int duration = Integer.parseInt(attributes[7]);
                        if (startX < 0 || startX > 19 || startY < 0 || startY > 19 || endX < 0 || endX > 19 || endY < 0 || endY > 19) {
                            System.out.println("One or more coordinates: start = (" + startX + "," + startY + ") , end = (" + endX + "," + endY + ") out of scope!");
                        } else {
                            Rent rent = new Rent(dateTime, attributes[1], attributes[2], startX, startY, endX, endY, duration, "da".equals(attributes[8]), "da".equals(attributes[9]));
                            rentList.add(rent);
                        }
                    }
                    else {
                        System.out.println("Not valid format of rent coordinates. Date: " + attributes[0]);
                    }
                } else {
                    System.out.println("Vehicle : " + attributes[2] + " in this rent doesn't exist in list of vehicles.");
                }
            }
        }catch (IOException exception) {
            exception.printStackTrace();
        }
    }

    //removes rent in list of rents that happen at the same time and have the same user
    private static void removeDuplicateUsers(List<Rent> rents) {
        Set<String> seenUserIds = new HashSet<>();
        Set<String> duplicateUserIds = new HashSet<>();
        for (Rent rent : rents) {
            if (!seenUserIds.add(rent.getUser())) {
                duplicateUserIds.add(rent.getUser());
            }
        }
        Iterator<Rent> iterator = rents.iterator();
        seenUserIds.clear();
        while (iterator.hasNext()) {
            Rent rent = iterator.next();
            if (duplicateUserIds.contains(rent.getUser())) {
                if (!seenUserIds.add(rent.getUser())) {
                    iterator.remove();
                }
            }
        }
    }

    //removes rent in list of rents that happen at the same time and have the same vehicle
    private static void removeDuplicateVehicle(List<Rent> rents) {
        Set<String> seenVehicleIds = new HashSet<>();
        Set<String> duplicateVehicleIds = new HashSet<>();
        for (Rent rent : rents) {
            if (!seenVehicleIds.add(rent.getVehicleId())) {
                duplicateVehicleIds.add(rent.getVehicleId());
            }
        }
        Iterator<Rent> iterator = rents.iterator();
        seenVehicleIds.clear();
        while (iterator.hasNext()) {
            Rent rent = iterator.next();
            if (duplicateVehicleIds.contains(rent.getVehicleId())) {
                if (!seenVehicleIds.add(rent.getVehicleId())) {
                    iterator.remove();
                }
            }
        }
    }


    //goes through map of rent lists and removes duplicate users and vehicles in rent list
    private static void removeDuplicates(Map<LocalDateTime, List<Rent>> groupedByDateTime) {
        for (Map.Entry<LocalDateTime, List<Rent>> entry : groupedByDateTime.entrySet()) {
            List<Rent> rentList = entry.getValue();
            removeDuplicateUsers(rentList);
            removeDuplicateVehicle(rentList);
        }
    }

    private static void updateUserRentCount(List<Rent> rentList) {
            rentList.stream().forEach(item -> {
                Optional<User> optionalUser = userList.stream().filter(user -> user.getUsername().equals(item.getUser())).findFirst();
                if(optionalUser.isPresent()) {
                    User user = optionalUser.get();
                    user.increaseRentCounter();
                   // System.out.println("User: " + user.getUsername() + " Rent counter: " + user.getRentCounter() + " rent: " + item.getId());
                    try {
                        if ((user.getRentCounter() % Integer.parseInt(Configuration.getUserDiscount())) == 0) {
                            //System.out.println("User: " + user.getUsername() + "Rent counter: " + user.getRentCounter() + " has discount.");
                            item.setHasDiscount(true);
                        }
                    }catch (IOException exception) {
                        exception.printStackTrace();
                    }
                }
            });
    }


    /**
     * Initialize the list of vehicles rented at the same time,
     * using the information from the list of rents made at the same.
     * @param rents the list of rents made at the same time
     */
    public static void updateCurrentVehicle(List<Rent> rents) {
        currentVehicles = new ArrayList<>();
        for(Rent rent: rents) {
            Optional<ElectricVehicle> optionalVehicle = vehicleList.stream().filter(vehicle -> vehicle.getVehicleId().equals(rent.getVehicleId())).findFirst();
            if (optionalVehicle.isPresent()) {
                ElectricVehicle electricVehicle = optionalVehicle.get();
                if (electricVehicle instanceof Bicycle) {
                    Bicycle bicycle = new Bicycle((Bicycle) electricVehicle);
                    bicycle.setStartX(rent.getStartX());
                    bicycle.setEndX(rent.getEndX());
                    bicycle.setStartY(rent.getStartY());
                    bicycle.setEndY(rent.getEndY());
                    bicycle.calculateFieldStay(rent.getDuration());
                    currentVehicles.add(bicycle);
                } else if (electricVehicle instanceof Car) {
                    Car car = new Car((Car) electricVehicle);
                    car.setStartX(rent.getStartX());
                    car.setEndX(rent.getEndX());
                    car.setStartY(rent.getStartY());
                    car.setEndY(rent.getEndY());
                    car.calculateFieldStay(rent.getDuration());
                    currentVehicles.add(car);
                } else {
                    Scooter scooter = new Scooter((Scooter) electricVehicle);
                    scooter.setStartX(rent.getStartX());
                    scooter.setEndX(rent.getEndX());
                    scooter.setStartY(rent.getStartY());
                    scooter.setEndY(rent.getEndY());
                    scooter.calculateFieldStay(rent.getDuration());
                    currentVehicles.add(scooter);
                }
            }
        }
    }

    /**
     *  Adds a pane to the grid representing the current state of the given electric vehicle.
     *  The pane includes a label with the electric vehicle's identifier and battery level, and an image of the vehicle.
     *  @param electricVehicle the electric vehicle to be represented on the grid
     */
    public static void addPaneToGrid(ElectricVehicle electricVehicle) {
        Label label = new Label(electricVehicle.getVehicleId() +" "+ electricVehicle.getBatteryLevel() + "%");
        ImageView imageView = new ImageView(electricVehicle.getImage());
            imageView.setFitHeight(15);
            imageView.setFitWidth(15);
            imageView.setLayoutX(5);
            imageView.setLayoutY(8);
            label.setLayoutX(5);
            label.setLayoutY(0);
            label.setStyle("-fx-font-size: 7; -fx-text-fill:black; -fx-font-weight: bold");

        Platform.runLater(()->{
            staticPanes[electricVehicle.getStartX()][electricVehicle.getStartY()].getChildren().addAll(imageView,label);;
            electricVehicle.batteryDischarge();
            if(electricVehicle.getBatteryLevel()==0){
                electricVehicle.setStartX(electricVehicle.getEndX());
                electricVehicle.setStartY(electricVehicle.getEndY());
            }

        });
    }

    /**
     * Removes the representation of the given electric vehicle from its current pane on the grid
     * and updates its position based on the specified direction.
     *  @param electricVehicle the electric vehicle to be removed from the grid
     *  @param addX {@code true}, the vehicle's x-coordinate will be incremented; {@code false}, decremented
     *  @param addY {@code true}, the vehicle's y-coordinate will be incremented; {@code false}, decremented
     */
    public static void removeFromPane(ElectricVehicle electricVehicle, boolean addX, boolean addY) {
            Platform.runLater(()->{
                removeLabelByText(staticPanes[electricVehicle.getStartX()][electricVehicle.getStartY()],electricVehicle.getVehicleId()+" "+(electricVehicle.getBatteryLevel()+5)+"%");
                removeImageViewByImage(staticPanes[electricVehicle.getStartX()][electricVehicle.getStartY()],electricVehicle.getImage());
                //startX++
                if(addX && !addY) {
                    electricVehicle.setStartX(electricVehicle.getStartX() + 1);
                }
                //startX--
                else if(!addX && !addY) {
                    electricVehicle.setStartX(electricVehicle.getStartX() - 1);
                }
                //startY++
                else if(!addX && addY) {
                    electricVehicle.setStartY(electricVehicle.getStartY() + 1);
                }
                //startY--
                else {
                    electricVehicle.setStartY(electricVehicle.getStartY() - 1);
                }
            });
    }
    private static void removeLabelByText(Pane pane, String text) {
        List<Node> children = pane.getChildren();
        for (Node node : children) {
            if (node instanceof Label && ((Label) node).getText().equals(text)) {
                children.remove(node);
                return;
            }
        }
    }

    private static void removeImageViewByImage(Pane pane, Image image) {
        List<Node> children = pane.getChildren();
        for (Node node : children) {
            if (node instanceof ImageView && ((ImageView) node).getImage().equals(image)) {
                children.remove(node);
                return;
            }
        }
    }

    /**
     *  Clears all panes in the grid, removing all visual representations of electric vehicles.
     */
    public static void clearAllPanes() {
        Platform.runLater(()->{
            for (int i = 0; i < 20; i++) {
                for (int j = 0; j < 20; j++) {
                staticPanes[i][j].getChildren().clear();
            }
        }
        });
    }

    /**
     *  Clears all fields in the city map, removing all vehicle lists.
     *  Each field represents a location on the map where vehicles can be placed.
     */
    public static void clearAllFields() {
        for (int i = 0; i < 20; i++) {
            for (int j = 0; j < 20; j++) {
                cityMap[i][j].getVehicleList().clear();
            }
        }
    }

    /**
     * Updates the map of invoices grouped by date.
     * This method collects all invoices from the {@code invoiceList} and groups them
     * by their date (LocalDate) into the {@code invoicesGroupedByDate} map.
     */
    public static void updateInvoicesDateMap() {
        invoicesGroupedByDate = invoiceList.stream().collect(Collectors.groupingBy(invoice -> invoice.getDateTime().toLocalDate()));
    }

    /**
     * Updates the list of reports based on the current list of invoices grouped by date.
     * This method iterates through the entries in the {@code invoicesGroupedByDate} map,
     * creates a new report for each date with the corresponding list of invoices,
     * and updates the {@code reportList} with the new reports.
     */
    public static void updateReportList() {
        List<Report> newReportList = new ArrayList<>();
        for (Map.Entry<LocalDate, List<Invoice>> entry : invoicesGroupedByDate.entrySet()) {
            List<Invoice> invoiceList = entry.getValue();
            LocalDate date = entry.getKey();
            Report report = new Report(date,invoiceList);
            newReportList.add(report);
        }
        reportList = newReportList;
    }

    //this method is called when all rents are finished
    private static void updateVehiclesIncomeMap() {
        Map<String,List<Invoice>> invoicesGroupedByVehicleId = invoiceList.stream().collect(Collectors.groupingBy(invoice -> invoice.getVehicleId()));
        for (Map.Entry<String, List<Invoice>> entry : invoicesGroupedByVehicleId.entrySet()) {
            List<Invoice> invoiceList = entry.getValue();
            String vehicleId = entry.getKey();
            AtomicReference<Double> atomicIncome = new AtomicReference<>(0.0);
            invoiceList.forEach(item-> atomicIncome.updateAndGet(v -> v + item.getFinalPrice()));
            Optional<ElectricVehicle> vehicleOptional = vehicleList.stream().filter(vehicle->vehicle.getVehicleId().equals(vehicleId)).findFirst();
            if(vehicleOptional.isPresent()) {
                ElectricVehicle electricVehicle = vehicleOptional.get();
                Double income = atomicIncome.get();
                //System.out.println("Vehicle id: " + electricVehicle.getVehicleId() + " - income: " + income);
                vehiclesIncomeMap.put(electricVehicle,income);
            }
        }
        findVehicles();
    }

    private static void findVehicles() {
        Map<Car,Double> carMap = new HashMap<>();
        Map<Bicycle,Double> bicycleMap = new HashMap<>();
        Map<Scooter,Double> scooterMap = new HashMap<>();
        for (Map.Entry<ElectricVehicle, Double> entry : vehiclesIncomeMap.entrySet()) {
            ElectricVehicle electricVehicle = entry.getKey();
            if(electricVehicle instanceof Car) {
                Car car = (Car) electricVehicle;
                carMap.put(car, entry.getValue());
            }
            else if(electricVehicle instanceof Bicycle) {
                Bicycle bicycle = (Bicycle) electricVehicle;
                bicycleMap.put(bicycle, entry.getValue());
            }
            else {
                Scooter scooter = (Scooter) electricVehicle;
                scooterMap.put(scooter, entry.getValue());
            }
        }
        Car carMaxIncome = findMaxEntry(carMap);
        Bicycle bicycleMaxIncome = findMaxEntry(bicycleMap);
        Scooter scooterMaxIncome = findMaxEntry(scooterMap);
        Double carIncome = vehiclesIncomeMap.get(carMaxIncome);
        Double bicycleIncome = vehiclesIncomeMap.get(bicycleMaxIncome);
        Double scooterIncome = vehiclesIncomeMap.get(scooterMaxIncome);
        try {
            serializeCar(carMaxIncome,Configuration.getCarSerializeFile());
            serializeBicycle(bicycleMaxIncome,Configuration.getBicycleSerializeFile());
            serializeScooter(scooterMaxIncome,Configuration.getScooterSerializeFile());
            serializeVehicleIncome(carIncome,Configuration.getCarIncomeSerializeFile());
            serializeVehicleIncome(bicycleIncome,Configuration.getBicycleIncomeSerializeFile());
            serializeVehicleIncome(scooterIncome,Configuration.getScooterIncomeSerializeFile());
            updateBtn();
        }catch (IOException exception) {
            exception.printStackTrace();
        }

        /*
        if(carMaxIncome!=null) {
            System.out.println("\nCar with max income: " + carMaxIncome.getVehicleId());
        }
        if(bicycleMaxIncome!=null) {
            System.out.println("\nBicycle with max income: " + bicycleMaxIncome.getVehicleId());
        }
        if(scooterMaxIncome!=null) {
            System.out.println("\nScooter with max income: " + scooterMaxIncome.getVehicleId());
        }*/

    }

    private static<K> K findMaxEntry(Map<K,Double> vehicleMap) {
        Map.Entry<K,Double> vehicleMaxEntry = null;
        for(Map.Entry<K,Double> entry: vehicleMap.entrySet()) {
            if(vehicleMaxEntry==null || entry.getValue().compareTo(vehicleMaxEntry.getValue())>0) {
                vehicleMaxEntry = entry;
            }
        }
        K vehicle = null;
        if(vehicleMaxEntry!=null) {
            vehicle = vehicleMaxEntry.getKey();
        }
        return vehicle;
    }



    private static void serializeCar(Car car, String fileName) throws IOException{
        FileOutputStream fileOutputStream = new FileOutputStream(Configuration.getUserDirProp() + File.separator + Configuration.getSerializePathProp() + File.separator + fileName);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(car);
        objectOutputStream.close();
    }

    private static void serializeBicycle(Bicycle bicycle, String fileName) throws IOException{
        FileOutputStream fileOutputStream = new FileOutputStream(Configuration.getUserDirProp() + File.separator + Configuration.getSerializePathProp() + File.separator + fileName);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(bicycle);
        objectOutputStream.close();
    }

    private static void serializeScooter(Scooter scooter, String fileName) throws IOException{
        FileOutputStream fileOutputStream = new FileOutputStream(Configuration.getUserDirProp() + File.separator + Configuration.getSerializePathProp() + File.separator + fileName);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(scooter);
        objectOutputStream.close();
    }

    private static void serializeVehicleIncome(Double income, String fileName) throws IOException{
        FileOutputStream fileOutputStream = new FileOutputStream(Configuration.getUserDirProp() + File.separator + Configuration.getSerializePathProp() + File.separator + fileName);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(income);
        objectOutputStream.close();
    }


    private Car deserializeCar(String fileName) throws IOException, ClassNotFoundException {
        FileInputStream fileInputStream = new FileInputStream(Configuration.getUserDirProp() + File.separator + Configuration.getSerializePathProp() + File.separator + fileName);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        return (Car)objectInputStream.readObject();
    }

    private Bicycle deserializeBicycle(String fileName) throws IOException, ClassNotFoundException {
        FileInputStream fileInputStream = new FileInputStream(Configuration.getUserDirProp() + File.separator + Configuration.getSerializePathProp() + File.separator + fileName);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        return (Bicycle)objectInputStream.readObject();
    }

    private Scooter deserializeScooter(String fileName) throws IOException, ClassNotFoundException {
        FileInputStream fileInputStream = new FileInputStream(Configuration.getUserDirProp() + File.separator + Configuration.getSerializePathProp() + File.separator + fileName);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        return (Scooter) objectInputStream.readObject();
    }

    private Double deserializeVehicleIncome(String fileName) throws IOException, ClassNotFoundException {
        FileInputStream fileInputStream = new FileInputStream(Configuration.getUserDirProp() + File.separator + Configuration.getSerializePathProp() + File.separator + fileName);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        Double income = (Double)objectInputStream.readObject();
        objectInputStream.close();
        return income;
    }

}
